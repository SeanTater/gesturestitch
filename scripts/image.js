// Generated by CoffeeScript 1.3.3
(function() {

  if (!(typeof gs !== "undefined" && gs !== null)) {
    window.gs = {};
  }

  jsfeat.point2d_t.prototype.toString = function() {
    return "" + this.x + "," + this.y;
  };

  gs.Image = (function() {
    /*
            Somewhat full-featured Image
            : brighten()
                A simple effect to demonstrate pixel manipulation.
            : display()
                Changes which element is shown (<img> or <canvas>)
            : features()
                Searches for 2d corners
            : place()
                Move the image around the ImageDisplay
            : scatter()
                place() and spin() the image randomly around the ImageDisplay
            : select() and deselect()
                Changes the style for user feedback
            : spin()
                Rotate the image (only in display, same in pixel manipulation)
    */

    function Image(args) {
      this.parent = args.parent;
      this.wrapper = $("<div class='Image_wrapper' />").draggable().click(this.toggleSelect.bind(this));
      if (args.pixels != null) {
        this.pixels = args.pixels;
        this.width = this.pixels.width;
        this.height = this.pixels.height;
        this.setupCanvas();
        this.draw();
        this.scatter();
      } else if (args.url != null) {
        this.image = $("<img/>");
        this.uimage = this.image[0];
        this.image.attr({
          src: args.url,
          "class": "Image"
        });
        this.display(this.image);
        this.image.load((function() {
          this.width = this.uimage.width;
          this.height = this.uimage.height;
          this.scatter();
          return this.setupCanvas();
        }).bind(this));
      }
      gs.Image.all.push(this);
    }

    Image.all = [];

    Image.prototype.display = function(element) {
      if (this.main != null) {
        this.main.remove();
      }
      this.main = element;
      this.main.appendTo(this.wrapper);
      this.wrapper.appendTo(this.parent.box);
      return this.main.on("contextmenu", $.proxy(this.handleMenuEvent, this));
    };

    Image.prototype.setupCanvas = function() {
      if (this.canvas != null) {
        return;
      }
      this.canvas = $("<canvas>");
      this.ucanvas = this.canvas[0];
      this.ucanvas.width = this.width;
      this.ucanvas.height = this.height;
      if (this.width * this.height === 0) {
        throw "Can't display a 0 size image";
      }
      this.context = this.ucanvas.getContext("2d");
      if (this.uimage != null) {
        this.context.drawImage(this.uimage, 0, 0);
      }
      this.display(this.canvas);
      if (this.uimage != null) {
        this.image_data = this.context.getImageData(0, 0, this.width, this.height);
        return this.pixels = new gs.Pixels({
          imdata: this.image_data
        });
      }
    };

    Image.prototype.unlink = function() {
      return this.wrapper.remove();
    };

    Image.prototype.save = function() {
      return this.draw(this.pixels);
    };

    Image.prototype.draw = function(pixels) {
      var i, i_data;
      this.setupCanvas();
      i_data = this.context.createImageData(this.width, this.height);
      i_data.data = this.pixels.data;
      i = this.pixels.data.length;
      while (--i > 0) {
        i_data.data[i] = this.pixels.data[i];
      }
      return this.context.putImageData(i_data, 0, 0);
    };

    Image.prototype.brighten = function() {
      this.setupCanvas();
      this.pixels.filter(function(x, y, pbright) {
        var vi, _i;
        for (vi = _i = 0; _i < 4; vi = ++_i) {
          pbright[vi] = pbright[vi] * 2;
        }
        return pbright;
      });
      return this.save();
    };

    Image.prototype.renderFeatures = function(corners) {
      var i, pixel, x, y, _i, _ref;
      pixel = new Uint8ClampedArray([0, 255, 0, 255]);
      for (i = _i = 0, _ref = corners.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        x = corners[i].x;
        y = corners[i].y;
        this.pixels.pixel(x + 1, y, pixel);
        this.pixels.pixel(x - 1, y, pixel);
        this.pixels.pixel(x, y + 1, pixel);
        this.pixels.pixel(x, y - 1, pixel);
      }
      return this.save();
    };

    Image.prototype.features = function() {
      var corners, count, i, imageData, img_u8, _ref, _ref1, _ref2, _ref3;
      this.setupCanvas();
      corners = [];
      i = this.width * this.height;
      while (--i >= 0) {
        corners[i] = new jsfeat.point2d_t(0, 0, 0, 0);
      }
      img_u8 = new jsfeat.matrix_t(this.width, this.height, jsfeat.U8_t | jsfeat.C1_t);
      imageData = this.context.getImageData(0, 0, this.width, this.height);
      jsfeat.imgproc.grayscale(this.pixels.data, img_u8.data);
      count = jsfeat.fast_corners.detect(img_u8, corners);
      console.log("" + count + " features before filtering");
      corners = corners.slice(0, count);
      i = corners.length;
      while (--i >= 0) {
        if (!((4 < (_ref = corners[i].x) && _ref < (this.width - 4)))) {
          console.log("" + corners[i].x + " failed x");
          [].splice.apply(corners, [i, i - i + 1].concat(_ref1 = [])), _ref1;
        } else if (!((4 < (_ref2 = corners[i].y) && _ref2 < (this.height - 4)))) {
          [].splice.apply(corners, [i, i - i + 1].concat(_ref3 = [])), _ref3;
        }
      }
      console.log("" + corners.length + " features after filtering");
      return corners;
    };

    Image.prototype.match = function(other_image) {
      var end, hs, index, len, our_features, our_region, pregion, start, swap, test, their_features, their_region, tr, _i, _j, _k, _results;
      our_features = this.features();
      their_features = other_image.features();
      hs = [];
      swap = function(i1, i2) {
        var temp;
        temp = their_features[i1];
        their_features[i1] = their_features[i2];
        their_features[i2] = temp;
      };
      pregion = function(pix, point) {
        return pix.region(point.x, point.y, 4);
      };
      len = Math.min(our_features.length, their_features.length);
      for (start = _i = 0; 0 <= len ? _i < len : _i > len; start = 0 <= len ? ++_i : --_i) {
        hs[start] = 1e100;
        our_region = pregion(this.pixels, our_features[start]);
        for (end = _j = start; start <= len ? _j < len : _j > len; end = start <= len ? ++_j : --_j) {
          their_region = pregion(other_image.pixels, their_features[end]);
          test = our_region.compareHistogram(their_region);
          if (test < hs[start]) {
            swap(start, end);
            hs[start] = test;
          }
        }
      }
      _results = [];
      for (index = _k = 0; 0 <= len ? _k < len : _k > len; index = 0 <= len ? ++_k : --_k) {
        tr = $("<tr>");
        tr.append($("<td>").text(our_features[index].x));
        tr.append($("<td>").text(our_features[index].y));
        tr.append($("<td>").text(their_features[index].x));
        tr.append($("<td>").text(their_features[index].y));
        tr.append($("<td>").text(hs[index]));
        $("#statistics").append(tr);
        _results.push({
          ours: our_features[index],
          theirs: their_features[index],
          movement: new jsfeat.point2d_t(their_features[index].x - our_features[index].x, their_features[index].y - our_features[index].y),
          score: 0
        });
      }
      return _results;
    };

    Image.prototype.estimateTranslation = function(matches) {
      var m1, m2, max_match, squared_distance, _i, _j, _len, _len1;
      max_match = matches[0];
      for (_i = 0, _len = matches.length; _i < _len; _i++) {
        m1 = matches[_i];
        for (_j = 0, _len1 = matches.length; _j < _len1; _j++) {
          m2 = matches[_j];
          squared_distance = Math.pow(m1.movement.x - m2.movement.x, 2) + Math.pow(m1.movement.y - m2.movement.y, 2) + 1;
          m1.score += 1 / squared_distance;
        }
        if (m1.score > max_match.score) {
          max_match = m1;
        }
      }
      return max_match.movement;
    };

    Image.prototype.overlay = function(other, trans) {
      return new gs.Image({
        pixels: this.pixels.merge(other.pixels, trans),
        parent: this.parent
      });
    };

    Image.prototype.handleMenuEvent = function(event) {
      event.preventDefault();
      return gs.ImageMenu.show(this, event);
    };

    Image.prototype.getCorners = function() {
      this.setupCanvas();
      return [[this.image.style.left, this.image.style.top], [this.image.style.left + this.pixels.cols, this.image.style.top], [this.image.style.left, this.image.style.top + this.pixels.rows], [this.image.style.left + this.pixels.cols, this.image.style.top + this.pixels.rows]];
    };

    Image.prototype.place = function(x, y) {
      return this.wrapper.css({
        position: "absolute",
        left: x,
        top: y
      });
    };

    Image.prototype.spin = function(degrees) {
      var renderer, _i, _len, _ref, _results;
      _ref = ['Webkit', 'Moz', 'O', 'MS', ''];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        renderer = _ref[_i];
        _results.push(this.wrapper.css("" + renderer + "Transform", "rotate(" + degrees + "deg)"));
      }
      return _results;
    };

    Image.prototype.scatter = function() {
      var degrees, x, x_limit, y, y_limit;
      degrees = Math.floor(Math.random() * 20) - 10;
      x_limit = this.parent.width - (this.wrapper.width() * 1.4);
      y_limit = this.parent.height - (this.wrapper.height() * 1.4);
      x = Math.floor(Math.random() * x_limit);
      y = Math.floor(Math.random() * y_limit);
      this.place(x, y);
      return this.spin(degrees);
    };

    Image.prototype.toggleSelect = function() {
      if (this.wrapper.hasClass("ui-selected")) {
        this.wrapper.removeClass("ui-selected");
        return this.parent.deselect(this);
      } else {
        this.wrapper.addClass("ui-selected");
        return this.parent.select(this);
      }
    };

    return Image;

  })();

}).call(this);
